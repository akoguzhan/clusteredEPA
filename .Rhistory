gamma_tot <- rep(gamma, each = Tobs)
D <- model.matrix(~ factor(gamma_tot) - 1)
U <- Z - D %*% theta
Sigma_hat <- t(U) %*% U / NT
K_tot <- length(c(theta)) + length(gamma)
BIC <- log(det(Sigma_hat)) + K_tot * kappa * log(NT) / NT
if (BIC < BIC_opt) {
BIC_opt <- BIC
best_result <- result
}
}
return(best_result)
}
if (is.null(G)) {
stop("Either G or Gmax must be specified.")
}
obj <- Inf
reps <- 1
while (reps <= Ninit) {
cluster_assign_list <- vector("list", iter.max + 1)
centroid_list <- vector("list", iter.max + 1)
objective_value <- vector("list", iter.max + 1)
iter <- 0
initial_sample <- sample(1:N, G, replace = FALSE)
ZbarT <- aggregate_matrix(Z, id)
current_centroid <- ZbarT[initial_sample, , drop = FALSE]
iter <- iter + 1
distance_matrix <- proxy::dist(current_centroid, ZbarT)^2
objectives <- wrMisc::rowGrpMeans(distance_matrix, id) * Tobs
gamma <- apply(objectives, 2, which.min)
gamma_tot <- rep(gamma, each = Tobs)
if (length(unique(gamma)) != G) {
next
} else {
reps <- reps + 1
}
centroid_list[[iter]] <- current_centroid
cluster_assign_list[[iter]] <- gamma
curr_objective_value <- sum(apply(objectives, 2, min))
objective_value[[iter]] <- curr_objective_value
same_cluster <- FALSE
while (iter <= iter.max && !same_cluster) {
iter <- iter + 1
current_centroid <- aggregate_matrix(Z, gamma_tot)
distance_matrix <- proxy::dist(current_centroid, Z)^2
objectives <- wrMisc::rowGrpMeans(distance_matrix, id)
gamma <- apply(objectives, 2, which.min)
gamma_tot <- rep(gamma, each = Tobs)
centroid_list[[iter]] <- current_centroid
cluster_assign_list[[iter]] <- gamma
same_cluster <- same_cl(gamma, cluster_assign_list[[iter - 1]], G)
objective_value[[iter]] <- sum(apply(objectives, 2, min))
}
obj_current <- min(unlist(objective_value))
if (obj_current < obj) {
cluster_assign_list <- cluster_assign_list[1:iter]
centroid_list <- centroid_list[1:iter]
objective_value <- objective_value[1:iter]
gamma_final <- cluster_assign_list[[iter]]
names(gamma_final) <- unique(id)
kmeans_final_results <- list(
clusters = cluster_assign_list,
centers = centroid_list,
objectives = objective_value,
iter = iter,
final_cluster = gamma_final,
random_init_obs = initial_sample
)
obj <- obj_current
}
}
return(kmeans_final_results)
}
# Required packages
library(cluster)   # For adjusted Rand index
library(mclust)    # For adjustedRandIndex
library(Matrix)    # For sparse matrix tools if needed
# Simulation parameters
set.seed(123)
N <- 50
Tobs <- 10
K <- 2
G_true <- 3
Gmax <- 5
n_sim <- 100
# DGP function
simulate_panel_data <- function(N, Tobs, K, G, separation = 1) {
group_sizes <- rep(floor(N/G), G)
group_sizes[G] <- N - sum(group_sizes[1:(G-1)])
group_labels <- rep(1:G, times = group_sizes)
centers <- matrix(rnorm(G * K, mean = 0, sd = separation), nrow = G)
Z <- matrix(NA, N * Tobs, K)
id_vec <- rep(1:N, each = Tobs)
for (i in 1:N) {
g <- group_labels[i]
Z_i <- matrix(rep(centers[g, ], each = Tobs), nrow = Tobs) +
matrix(rnorm(Tobs * K, sd = 1), nrow = Tobs)
Z[((i - 1) * Tobs + 1):(i * Tobs), ] <- Z_i
}
list(Z = Z, id = id_vec, true_cluster = group_labels)
}
# Performance metrics
rand_recovery <- function(true, est) {
ari <- mclust::adjustedRandIndex(true, est)
recovery <- sum(true == est) / length(true)
return(c(rand = ari, recovery = recovery))
}
# Monte Carlo loop
results <- matrix(NA, nrow = n_sim, ncol = 4)
colnames(results) <- c("Rand", "Recovery", "BIC_Selects_Correct_G", "Ghat")
for (sim in 1:n_sim) {
data <- simulate_panel_data(N, Tobs, K, G_true)
Z <- data$Z
id <- data$id
true_cl <- data$true_cluster
# Estimate with fixed G
fit_fixed <- panel_kmeans_estimation(Z = Z, id = id, G = G_true, Ninit = 10, iter.max = 10)
est_cl <- fit_fixed$final_cluster
metrics <- rand_recovery(true_cl, est_cl)
# Estimate with BIC
fit_bic <- panel_kmeans_estimation(Z = Z, id = id, Gmax = Gmax, Ninit = 10, iter.max = 10)
Ghat <- length(unique(fit_bic$final_cluster))
results[sim, ] <- c(metrics, Ghat == G_true, Ghat)
}
# Required packages
library(cluster)   # For adjusted Rand index
library(mclust)    # For adjustedRandIndex
library(Matrix)    # For sparse matrix tools if needed
# Simulation parameters
set.seed(123)
N <- 50
Tobs <- 10
K <- 2
G_true <- 3
Gmax <- 5
n_sim <- 100
# DGP function
simulate_panel_data <- function(N, Tobs, K, G, separation = 1) {
group_sizes <- rep(floor(N/G), G)
group_sizes[G] <- N - sum(group_sizes[1:(G-1)])
group_labels <- rep(1:G, times = group_sizes)
centers <- matrix(rnorm(G * K, mean = 0, sd = separation), nrow = G)
Z <- matrix(NA, N * Tobs, K)
id_vec <- rep(1:N, each = Tobs)
for (i in 1:N) {
g <- group_labels[i]
Z_i <- matrix(rep(centers[g, ], each = Tobs), nrow = Tobs) +
matrix(rnorm(Tobs * K, sd = 1), nrow = Tobs)
Z[((i - 1) * Tobs + 1):(i * Tobs), ] <- Z_i
}
list(Z = Z, id = id_vec, true_cluster = group_labels)
}
# Performance metrics
rand_recovery <- function(true, est) {
ari <- mclust::adjustedRandIndex(true, est)
recovery <- sum(true == est) / length(true)
return(c(rand = ari, recovery = recovery))
}
# Monte Carlo loop
results <- matrix(NA, nrow = n_sim, ncol = 4)
colnames(results) <- c("Rand", "Recovery", "BIC_Selects_Correct_G", "Ghat")
for (sim in 1:n_sim) {
data <- simulate_panel_data(N, Tobs, K, G_true)
Z <- data$Z
id <- data$id
true_cl <- data$true_cluster
# Estimate with fixed G
fit_fixed <- panel_kmeans_estimation(Z = Z, id = id, G = G_true, Ninit = 10, iter.max = 10)
est_cl <- fit_fixed$final_cluster
metrics <- rand_recovery(true_cl, est_cl)
# Estimate with BIC
fit_bic <- panel_kmeans_estimation(Z = Z, id = id, Gmax = Gmax, Ninit = 10, iter.max = 10)
Ghat <- length(unique(fit_bic$final_cluster))
results[sim, ] <- c(metrics, Ghat == G_true, Ghat)
}
# Required packages
library(cluster)   # For adjusted Rand index
library(mclust)    # For adjustedRandIndex
library(Matrix)    # For sparse matrix tools if needed
# Simulation parameters
set.seed(123)
N <- 50
Tobs <- 10
K <- 2
G_true <- 3
Gmax <- 5
n_sim <- 100
# DGP function
simulate_panel_data <- function(N, Tobs, K, G, separation = 1) {
group_sizes <- rep(floor(N/G), G)
group_sizes[G] <- N - sum(group_sizes[1:(G-1)])
group_labels <- rep(1:G, times = group_sizes)
centers <- matrix(rnorm(G * K, mean = 0, sd = separation), nrow = G)
Z <- matrix(NA, N * Tobs, K)
id_vec <- rep(1:N, each = Tobs)
for (i in 1:N) {
g <- group_labels[i]
Z_i <- matrix(rep(centers[g, ], each = Tobs), nrow = Tobs) +
matrix(rnorm(Tobs * K, sd = 1), nrow = Tobs)
Z[((i - 1) * Tobs + 1):(i * Tobs), ] <- Z_i
}
list(Z = Z, id = id_vec, true_cluster = group_labels)
}
# Performance metrics
rand_recovery <- function(true, est) {
ari <- mclust::adjustedRandIndex(true, est)
recovery <- sum(true == est) / length(true)
return(c(rand = ari, recovery = recovery))
}
# Monte Carlo loop
results <- matrix(NA, nrow = n_sim, ncol = 4)
colnames(results) <- c("Rand", "Recovery", "BIC_Selects_Correct_G", "Ghat")
for (sim in 1:n_sim) {
data <- simulate_panel_data(N, Tobs, K, G_true)
Z <- data$Z
id <- data$id
true_cl <- data$true_cluster
# Estimate with fixed G
fit_fixed <- panel_kmeans_estimation(Z = Z, id = id, G = G_true, Ninit = 10, iter.max = 10)
est_cl <- fit_fixed$final_cluster
metrics <- rand_recovery(true_cl, est_cl)
# Estimate with BIC
fit_bic <- panel_kmeans_estimation(Z = Z, id = id, Gmax = Gmax, Ninit = 10, iter.max = 10)
Ghat <- length(unique(fit_bic$final_cluster))
results[sim, ] <- c(metrics, Ghat == G_true, Ghat)
}
#' Panel K-means Estimation with Optional BIC Selection
#'
#' This function performs K-means clustering on NT x K matrix panel data. If `Gmax` is provided,
#' it performs model selection using BIC over 2 to `Gmax` clusters. Otherwise, clustering is
#' performed using the provided `G`.
#'
#' @param Z NT x K matrix of variables for clustering (typically averaged over time)
#' @param id NT-length vector of unit identifiers (repeating across time)
#' @param G Integer; number of clusters. Required unless Gmax is provided.
#' @param Gmax Optional; if provided, perform BIC-based selection from 2 to Gmax clusters.
#' @param Ninit Number of random initializations
#' @param iter.max Maximum number of Lloyd iterations
#'
#' @return A list with: clusters, centers, objectives, iter, final_cluster, random_init_obs
#' @export
#'
panel_kmeans_estimation <- function(Z, id, G = NULL, Gmax = NULL, Ninit = 10, iter.max = 10) {
# requireNamespace(proxy)
# requireNamespace(wrMisc)
N <- length(unique(id))
Tobs <- sum(id == id[1])
K <- ncol(Z)
NT <- N * Tobs
kappa <- 3
if (!is.null(Gmax)) {
BIC_opt <- Inf
for (Gi in 2:Gmax) {
result <- panel_kmeans_estimation(Z, id, G = Gi, Ninit = Ninit, iter.max = iter.max)
theta <- result$centers[[result$iter]]
gamma <- result$final_cluster
gamma_tot <- rep(gamma, each = Tobs)
D <- model.matrix(~ factor(gamma_tot) - 1)
U <- Z - D %*% theta
Sigma_hat <- t(U) %*% U / NT
K_tot <- length(c(theta)) + length(gamma)
BIC <- log(det(Sigma_hat)) + K_tot * kappa * log(NT) / NT
if (BIC < BIC_opt) {
BIC_opt <- BIC
best_result <- result
}
}
return(best_result)
}
if (is.null(G)) {
stop("Either G or Gmax must be specified.")
}
obj <- Inf
reps <- 1
while (reps <= Ninit) {
cluster_assign_list <- vector("list", iter.max + 1)
centroid_list <- vector("list", iter.max + 1)
objective_value <- vector("list", iter.max + 1)
iter <- 0
initial_sample <- sample(1:N, G, replace = FALSE)
ZbarT <- aggregate_matrix(Z, id)
current_centroid <- ZbarT[initial_sample, , drop = FALSE]
iter <- iter + 1
distance_matrix <- proxy::dist(current_centroid, ZbarT)^2
objectives <- wrMisc::rowGrpMeans(distance_matrix, id) * Tobs
gamma <- apply(objectives, 2, which.min)
gamma_tot <- rep(gamma, each = Tobs)
if (length(unique(gamma)) != G) {
next
} else {
reps <- reps + 1
}
centroid_list[[iter]] <- current_centroid
cluster_assign_list[[iter]] <- gamma
curr_objective_value <- sum(apply(objectives, 2, min))
objective_value[[iter]] <- curr_objective_value
same_cluster <- FALSE
while (iter <= iter.max && !same_cluster) {
iter <- iter + 1
current_centroid <- aggregate_matrix(Z, gamma_tot)
distance_matrix <- proxy::dist(current_centroid, Z)^2
objectives <- wrMisc::rowGrpMeans(distance_matrix, id)
gamma <- apply(objectives, 2, which.min)
gamma_tot <- rep(gamma, each = Tobs)
centroid_list[[iter]] <- current_centroid
cluster_assign_list[[iter]] <- gamma
same_cluster <- same_cl(gamma, cluster_assign_list[[iter - 1]], G)
objective_value[[iter]] <- sum(apply(objectives, 2, min))
}
obj_current <- min(unlist(objective_value))
if (obj_current < obj) {
cluster_assign_list <- cluster_assign_list[1:iter]
centroid_list <- centroid_list[1:iter]
objective_value <- objective_value[1:iter]
gamma_final <- cluster_assign_list[[iter]]
names(gamma_final) <- unique(id)
kmeans_final_results <- list(
clusters = cluster_assign_list,
centers = centroid_list,
objectives = objective_value,
iter = iter,
final_cluster = gamma_final,
random_init_obs = initial_sample
)
obj <- obj_current
}
}
return(kmeans_final_results)
}
# Required packages
library(cluster)   # For adjusted Rand index
library(mclust)    # For adjustedRandIndex
library(Matrix)    # For sparse matrix tools if needed
# Simulation parameters
set.seed(123)
N <- 50
Tobs <- 10
K <- 2
G_true <- 3
Gmax <- 5
n_sim <- 100
# DGP function
simulate_panel_data <- function(N, Tobs, K, G, separation = 1) {
group_sizes <- rep(floor(N/G), G)
group_sizes[G] <- N - sum(group_sizes[1:(G-1)])
group_labels <- rep(1:G, times = group_sizes)
centers <- matrix(rnorm(G * K, mean = 0, sd = separation), nrow = G)
Z <- matrix(NA, N * Tobs, K)
id_vec <- rep(1:N, each = Tobs)
for (i in 1:N) {
g <- group_labels[i]
Z_i <- matrix(rep(centers[g, ], each = Tobs), nrow = Tobs) +
matrix(rnorm(Tobs * K, sd = 1), nrow = Tobs)
Z[((i - 1) * Tobs + 1):(i * Tobs), ] <- Z_i
}
list(Z = Z, id = id_vec, true_cluster = group_labels)
}
# Performance metrics
rand_recovery <- function(true, est) {
ari <- mclust::adjustedRandIndex(true, est)
recovery <- sum(true == est) / length(true)
return(c(rand = ari, recovery = recovery))
}
# Monte Carlo loop
results <- matrix(NA, nrow = n_sim, ncol = 4)
colnames(results) <- c("Rand", "Recovery", "BIC_Selects_Correct_G", "Ghat")
for (sim in 1:n_sim) {
data <- simulate_panel_data(N, Tobs, K, G_true)
Z <- data$Z
id <- data$id
true_cl <- data$true_cluster
# Estimate with fixed G
fit_fixed <- panel_kmeans_estimation(Z = Z, id = id, G = G_true, Ninit = 10, iter.max = 10)
est_cl <- fit_fixed$final_cluster
metrics <- rand_recovery(true_cl, est_cl)
# Estimate with BIC
fit_bic <- panel_kmeans_estimation(Z = Z, id = id, Gmax = Gmax, Ninit = 10, iter.max = 10)
Ghat <- length(unique(fit_bic$final_cluster))
results[sim, ] <- c(metrics, Ghat == G_true, Ghat)
}
#' Compute Group Means by Cluster Membership
#'
#' @description Computes column means of a numeric matrix grouped by a vector of categorical indicators.
#'
#' @param X A numeric matrix of size N x K.
#' @param v A vector of group membership indicators of length N.
#'
#' @return A G x K matrix of group means, where G is the number of unique values in \code{v}.
#' @keywords internal
#'
aggregate_matrix = function(X,v) {
if (!is.matrix(X)) {
stop("X has to be a matrix")
}
K = dim(X)[2]
if (K==1) {
require(Rfast)
Xbar = as.matrix(group(X,v,method="mean"))
} else {
require(wrMisc)
Xbar = t(rowGrpMeans(t(X),v))
}
return(Xbar)
}
# Required packages
library(cluster)   # For adjusted Rand index
library(mclust)    # For adjustedRandIndex
library(Matrix)    # For sparse matrix tools if needed
# Simulation parameters
set.seed(123)
N <- 50
Tobs <- 10
K <- 2
G_true <- 3
Gmax <- 5
n_sim <- 100
# DGP function
simulate_panel_data <- function(N, Tobs, K, G, separation = 1) {
group_sizes <- rep(floor(N/G), G)
group_sizes[G] <- N - sum(group_sizes[1:(G-1)])
group_labels <- rep(1:G, times = group_sizes)
centers <- matrix(rnorm(G * K, mean = 0, sd = separation), nrow = G)
Z <- matrix(NA, N * Tobs, K)
id_vec <- rep(1:N, each = Tobs)
for (i in 1:N) {
g <- group_labels[i]
Z_i <- matrix(rep(centers[g, ], each = Tobs), nrow = Tobs) +
matrix(rnorm(Tobs * K, sd = 1), nrow = Tobs)
Z[((i - 1) * Tobs + 1):(i * Tobs), ] <- Z_i
}
list(Z = Z, id = id_vec, true_cluster = group_labels)
}
# Performance metrics
rand_recovery <- function(true, est) {
ari <- mclust::adjustedRandIndex(true, est)
recovery <- sum(true == est) / length(true)
return(c(rand = ari, recovery = recovery))
}
# Monte Carlo loop
results <- matrix(NA, nrow = n_sim, ncol = 4)
colnames(results) <- c("Rand", "Recovery", "BIC_Selects_Correct_G", "Ghat")
for (sim in 1:n_sim) {
data <- simulate_panel_data(N, Tobs, K, G_true)
Z <- data$Z
id <- data$id
true_cl <- data$true_cluster
# Estimate with fixed G
fit_fixed <- panel_kmeans_estimation(Z = Z, id = id, G = G_true, Ninit = 10, iter.max = 10)
est_cl <- fit_fixed$final_cluster
metrics <- rand_recovery(true_cl, est_cl)
# Estimate with BIC
fit_bic <- panel_kmeans_estimation(Z = Z, id = id, Gmax = Gmax, Ninit = 10, iter.max = 10)
Ghat <- length(unique(fit_bic$final_cluster))
results[sim, ] <- c(metrics, Ghat == G_true, Ghat)
}
# Required packages
library(cluster)   # For adjusted Rand index
library(mclust)    # For adjustedRandIndex
library(Matrix)    # For sparse matrix tools if needed
# Simulation parameters
set.seed(123)
N <- 50
Tobs <- 10
K <- 2
G_true <- 3
Gmax <- 5
n_sim <- 100
# DGP function
simulate_panel_data <- function(N, Tobs, K, G, separation = 1) {
group_sizes <- rep(floor(N/G), G)
group_sizes[G] <- N - sum(group_sizes[1:(G-1)])
group_labels <- rep(1:G, times = group_sizes)
centers <- matrix(rnorm(G * K, mean = 0, sd = separation), nrow = G)
Z <- matrix(NA, N * Tobs, K)
id_vec <- rep(1:N, each = Tobs)
for (i in 1:N) {
g <- group_labels[i]
Z_i <- matrix(rep(centers[g, ], each = Tobs), nrow = Tobs) +
matrix(rnorm(Tobs * K, sd = 1), nrow = Tobs)
Z[((i - 1) * Tobs + 1):(i * Tobs), ] <- Z_i
}
list(Z = Z, id = id_vec, true_cluster = group_labels)
}
View(data)
# Required packages
library(cluster)   # For adjusted Rand index
library(mclust)    # For adjustedRandIndex
library(Matrix)    # For sparse matrix tools if needed
# Simulation parameters
set.seed(123)
N <- 50
Tobs <- 10
P <- 2
K_true <- 3
Kmax <- 5
n_sim <- 100
# DGP function
simulate_panel_data <- function(N, Tobs, P, K, separation = 1) {
group_sizes <- rep(floor(N/K), K)
group_sizes[K] <- N - sum(group_sizes[1:(K-1)])
group_labels <- rep(1:K, times = group_sizes)
centers <- matrix(rnorm(K * P, mean = 0, sd = separation), nrow = K)
Z <- matrix(NA, N * Tobs, P)
id_vec <- rep(1:N, each = Tobs)
for (i in 1:N) {
g <- group_labels[i]
Z_i <- matrix(rep(centers[g, ], each = Tobs), nrow = Tobs) +
matrix(rnorm(Tobs * P, sd = 1), nrow = Tobs)
Z[((i - 1) * Tobs + 1):(i * Tobs), ] <- Z_i
}
list(Z = Z, id = id_vec, true_cluster = group_labels)
}
